function gameResult(seed) {
  const nBits = 52; // number of most significant bits to use
  const hmac = crypto.createHmac("sha256", salt);
  hmac.update(Buffer.from(seed, "hex"));
  const r = parseInt(hmac.digest("hex").slice(0, nBits / 4), 16);
  let X = r / Math.pow(2, nBits); // uniformly distributed in [0; 1)
  X = 99 / (1 - X);
  const result = Math.floor(X);
  return Math.max(1, result / 100);








#Hash-based message authentication codes (HMAC)
#Hash-based message authentication codes (or HMACs) are a tool for calculating message authentication codes using a 
#cryptographic hash function coupled with a secret key. You can use an HMAC to verify both the integrity and authenticity of a message.

classcryptography.hazmat.primitives.hmac.HMAC(key, algorithm, backend=None)
#HMAC objects take a key and a HashAlgorithm instance. The key should be randomly generated bytes and is recommended 
#to be equal in length to the digest_size of the hash function chosen. You must keep the key secret.

#This is an implementation of RFC 2104.

>>> from cryptography.hazmat.primitives import hashes, hmac
>>> h = hmac.HMAC(key, hashes.SHA256())
>>> h.update(b"message to hash")
>>> h.finalize()








  # Parallel computing
import ipyparallel as ipp
# Helper functions
from Experiments.helperfuncs import save_experiment,load_experiment



print("{} {}".format(index, list_item))